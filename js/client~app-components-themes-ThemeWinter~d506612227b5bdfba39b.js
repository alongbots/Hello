try{let e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="4ae7aff5-b6b0-487f-88c2-81c48d09671f",e._sentryDebugIdIdentifier="sentry-dbid-4ae7aff5-b6b0-487f-88c2-81c48d09671f")}catch(e){}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{}).SENTRY_RELEASE={id:"d8ea849a8f6630d596dadf4704adb6de069d21ff"};(self.__LOADABLE_LOADED_CHUNKS__=self.__LOADABLE_LOADED_CHUNKS__||[]).push([[3183,4454,9325],{44996:(e,n,t)=>{t.r(n),t.d(n,{default:()=>s});var o=t(17402),a=t(68154),i=t(98241),r=t(95901);function s(){const e=(0,o.useRef)(!0),[n,s]=(0,o.useState)({default:""});return(0,o.useEffect)((()=>(t.e(541).then(t.bind(t,26718)).then((n=>{e.current&&s(n),Array.from(document.querySelectorAll(".summaryTile")).forEach((e=>{const n=Math.floor(3*Math.random())+1;e.style.setProperty("--xmasSnow",`url(https://a.poki-cdn.com/cdn-cgi/image/f=auto,quality=78/eastereggs/xmas-snow-1x1-${n}-v2.svg)`);const t=Math.floor(2*Math.random())+1;e.style.setProperty("--xmasSnow2x2",`url(https://a.poki-cdn.com/cdn-cgi/image/f=auto,quality=78/eastereggs/xmas-snow-2x2-${t}-v2.svg)`),e.style.setProperty("--xmasSnow3x3",`url(https://a.poki-cdn.com/cdn-cgi/image/f=auto,quality=78/eastereggs/xmas-snow-3x3-${t}-v2.svg)`)}))})),()=>{e.current=!1})),[]),(0,r.FD)(r.FK,{children:[(0,r.Y)(a.m,{children:(0,r.Y)("style",{children:n.default})}),(0,r.Y)(i.default,{})]})}},97616:(e,n,t)=>{t.r(n),t.d(n,{themeWinterSnow:()=>o});var o="teqlJ2S9AJ8xETObmuWa"},98241:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});var o=t(17402),a=t(97616),i=t(95901);function r(){const e=(0,o.useRef)(null);return(0,o.useEffect)((()=>{let n;if(e.current){const t=function(e){const n=e.getContext("webgl",{alpha:!0,antialias:!0});if(!n)return null;n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.clearColor(0,0,0,0);const t=f(n,n.VERTEX_SHADER,s),o=f(n,n.FRAGMENT_SHADER,l);if(!t||!o)return null;const a=n.createProgram();if(!a)return null;if(n.attachShader(a,t),n.attachShader(a,o),n.linkProgram(a),!n.getProgramParameter(a,n.LINK_STATUS))return console.error("Program linking error:",n.getProgramInfoLog(a)),null;const i={position:n.getAttribLocation(a,"vertexPosition"),texCoord:n.getAttribLocation(a,"textureCoord"),time:n.getUniformLocation(a,"currentTime"),resolution:n.getUniformLocation(a,"screenResolution")},r=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,r),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),n.STATIC_DRAW);const d=n.createBuffer();function c(){const t=e.clientWidth,o=e.clientHeight;e.width===t&&e.height===o||(e.width=t,e.height=o,n.viewport(0,0,e.width,e.height))}return n.bindBuffer(n.ARRAY_BUFFER,d),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),n.STATIC_DRAW),window.addEventListener("resize",c),c(),function(t){n.clear(n.COLOR_BUFFER_BIT),n.useProgram(a),n.uniform1f(i.time,.001*t),n.uniform2f(i.resolution,e.width,e.height),n.enableVertexAttribArray(i.position),n.bindBuffer(n.ARRAY_BUFFER,r),n.vertexAttribPointer(i.position,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(i.texCoord),n.bindBuffer(n.ARRAY_BUFFER,d),n.vertexAttribPointer(i.texCoord,2,n.FLOAT,!1,0,0),n.drawArrays(n.TRIANGLE_STRIP,0,4)}}(e.current);if(t){const e=o=>{t(o),n=requestAnimationFrame(e)};e(0)}}return()=>{cancelAnimationFrame(n)}}),[]),(0,i.Y)("canvas",{className:a.themeWinterSnow,ref:e})}const s="\n    attribute vec4 vertexPosition;\n    attribute vec2 textureCoord;\n    varying vec2 pixelCoord;\n\n    void main() {\n        gl_Position = vertexPosition;\n        pixelCoord = textureCoord * 2.0 - 1.0;\n    }\n",l="\nprecision highp float;\nvarying vec2 pixelCoord;\nuniform float currentTime;\nuniform vec2 screenResolution;\n\nfloat random(vec2 p) {\n    p = fract(p * vec2(0.1031, 0.1030));\n    p += dot(p, p + 31.32);\n    return fract((p.x + p.y) * p.x);\n}\n\nfloat drawCircle(vec2 position, vec2 center, float radius) {\n    float d = length(position - center);\n    float edge = radius * 0.2; // Controls edge softness - smaller number = sharper edge\n    return smoothstep(radius + edge, radius - edge, d);\n}\n\nvoid main() {\n    vec2 uv = pixelCoord;\n    float aspectRatio = screenResolution.x / screenResolution.y;\n\n    uv.x = (uv.x + 1.0) * 0.5 * aspectRatio;\n    uv.y = (uv.y + 1.0) * 0.5;\n\n    float padding = 0.2;\n    uv.x = (uv.x * (1.0 + 2.0 * padding)) - padding * aspectRatio;\n    uv.y = (uv.y * (1.0 + 2.0 * padding)) - padding;\n\n    float snowAccumulation = 0.0;\n    float stableTime = currentTime * 0.5;\n\n    const int maxLayers = 4;\n    const int maxSizes = 4;\n\n    for (int layer = 0; layer < maxLayers; layer++) {\n        for (int size = 0; size < maxSizes; size++) {\n            float flakeSize = 2.0 + float(size);\n\n            float baseSpeed = 0.3;\n            float windDrift = 0.02 * sin((stableTime + float(layer * 6185)) * 0.6 + float(size));\n            float heightBasedDrift = 3.0 / float(size + 1);\n            float fallSpeed = baseSpeed;\n\n            vec2 snowUV = uv + vec2(\n                windDrift * heightBasedDrift,\n                fallSpeed * (stableTime + float(layer * 1352)) * (1.0 / float(size + 1))\n            );\n\n            snowUV = fract(snowUV);\n\n            vec2 gridPosition = (floor(snowUV * flakeSize * 10.0) + 0.5) / (flakeSize * 10.0);\n\n\n            float cellSize = 1.0 / (flakeSize * 10.0);\nfloat offsetRange = 0.8 * (cellSize * 0.5); // 80% of half cell size\n\nfloat offsetX = (random(gridPosition + float(layer) * 12.0) - 0.5) * (2.0 * offsetRange);\nfloat offsetY = (random(gridPosition + float(layer) * 23.0) - 0.5) * (2.0 * offsetRange);\n\n            float swirlX = sin(stableTime * 0.5) * 0.5 / flakeSize;\n            float swirlY = cos(stableTime * 0.5) * 0.5 / flakeSize;\n\n            vec2 snowflakeOffset = vec2(offsetX * sin(offsetY), offsetY) * swirlX +\n                                 vec2(offsetY, offsetX) * swirlY;\n            vec2 finalPosition = gridPosition + snowflakeOffset * 0.8;\n\n            float snowflakeProbability = random(gridPosition * 43.16);\n\n            if (snowflakeProbability < 0.01) {\n                float baseRadius = 0.01;\n                float sizeScale = 1.0 / (float(size) * 0.5 + 1.0);\n                float radius = baseRadius * sizeScale;\n\n                float flakeMask = drawCircle(snowUV, finalPosition, radius);\n\n                float sizeIntensity = 1.0 / (float(size) * 0.2 + 1.0);\n                float randomIntensity = 0.7 + random(gridPosition) * 0.3;\n                float intensity = sizeIntensity * randomIntensity * flakeMask;\n\n                snowAccumulation += intensity * 0.8;\n            }\n        }\n    }\n\n    snowAccumulation = min(snowAccumulation, 1.0);\n    gl_FragColor = vec4(vec3(1.0), snowAccumulation);\n}\n";function f(e,n,t){const o=e.createShader(n);return o?(e.shaderSource(o,t),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(console.error("Shader compilation error:",e.getShaderInfoLog(o)),e.deleteShader(o),null)):null}}}]);
//# sourceMappingURL=client~app-components-themes-ThemeWinter~d506612227b5bdfba39b.js.map